name: Update README last-updated

permissions:
  contents: write

on:
  push:
    branches: [ main, master ]
    # optional: to avoid running when only this workflow changes
    # paths-ignore:
    #   - '.github/workflows/update-readme-timestamp.yml'

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: Skip if action itself triggered this run
        if: ${{ github.actor == 'github-actions' }}
        run: |
          echo "Triggered by github-actions. Exiting to avoid loop."
          exit 0

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update README Last Updated table
        env:
          TZ: 'Asia/Kolkata'   # change or remove as needed
        run: |
          set -euo pipefail

          # 1) locate README (customize paths if needed)
          README=README.md
          if [ ! -f "$README" ]; then README=Setup/ReadMe-Softwares-List.md; fi
          if [ ! -f "$README" ]; then
            echo "README not found at expected paths. Exiting."
            exit 0
          fi

          # export README path for later steps
          echo "README determined as: $README"
          echo "README=$README" >> $GITHUB_ENV

          # 2) gather metadata
          NEW_DATE="$(date '+%Y-%m-%d %H:%M %z')"
          REPO="${GITHUB_REPOSITORY}"
          BRANCH="${GITHUB_REF_NAME:-$(echo ${GITHUB_REF} | sed 's#refs/heads/##')}"
          ACTOR="${GITHUB_ACTOR}"
          COMMIT_SHA="$(git rev-parse --short HEAD 2>/dev/null || echo ${GITHUB_SHA:0:7})"
          COMMIT_URL="https://github.com/${REPO}/commit/${COMMIT_SHA}"
          COMMIT_MSG="$(git log -1 --pretty=%s 2>/dev/null || (jq -r '.head_commit.message // ""' "$GITHUB_EVENT_PATH" 2>/dev/null) || echo "")"
          ESC_COMMIT_MSG="$(printf '%s' "$COMMIT_MSG" | sed 's/`/`'\"'\"'`/g')"
          COMPARE_URL="https://github.com/${REPO}/compare/${GITHUB_SHA}^...${GITHUB_SHA}"
          RUN_URL="https://github.com/${REPO}/actions/runs/${GITHUB_RUN_ID}"
          RUN_NUM="${GITHUB_RUN_NUMBER:-${GITHUB_RUN_ID}}"

          # 3) write markdown table to temp file (variables expanded)
          cat > /tmp/details.md <<'MD_EOF'
## 📅 Last Updated

| Field             | Details |
| ----------------- | ------- |
| 🗓️ Date/Time      | `__NEW_DATE__` |
| 📦 Repository     | `__REPO__` |
| 🔀 Branch         | `__BRANCH__` |
| 👤 Author         | `__ACTOR__` |
| 📝 Commit Message | `__ESC_COMMIT_MSG__` |
| 🔗 Commit         | [`__COMMIT_SHA__`](__COMMIT_URL__) |
| 📊 Compare        | [View changes](__COMPARE_URL__) |
| ⚙️ Workflow Run   | [Run #__RUN_NUM__](__RUN_URL__) |
MD_EOF

          # Replace placeholders with actual values safely
          sed -i "s|__NEW_DATE__|$NEW_DATE|g" /tmp/details.md
          sed -i "s|__REPO__|$REPO|g" /tmp/details.md
          sed -i "s|__BRANCH__|$BRANCH|g" /tmp/details.md
          sed -i "s|__ACTOR__|$ACTOR|g" /tmp/details.md
          # Use a safe delimiter for commit message replacement
          sed -i "s|__ESC_COMMIT_MSG__|$(printf '%s' "$ESC_COMMIT_MSG" | sed 's|[&/\]|\\&|g')|g" /tmp/details.md
          sed -i "s|__COMMIT_SHA__|$COMMIT_SHA|g" /tmp/details.md
          sed -i "s|__COMMIT_URL__|$COMMIT_URL|g" /tmp/details.md
          sed -i "s|__COMPARE_URL__|$COMPARE_URL|g" /tmp/details.md
          sed -i "s|__RUN_URL__|$RUN_URL|g" /tmp/details.md
          sed -i "s|__RUN_NUM__|$RUN_NUM|g" /tmp/details.md

          echo "Prepared /tmp/details.md:"
          sed -n '1,200p' /tmp/details.md

          # 4) Replace existing "## 📅 Last Updated" block (until next top-level '## ' heading) with the temp file
          if grep -q '^## 📅 Last Updated' "$README"; then
            awk '
              BEGIN { printed=0; skip=0; }
              {
                if ($0 ~ /^## 📅 Last Updated/ && printed==0) {
                  while ((getline line < "/tmp/details.md") > 0) print line;
                  printed=1;
                  skip=1;
                  next;
                }
                if (skip==1 && $0 ~ /^## /) {
                  skip=0;
                  print $0;
                  next;
                }
                if (skip==1) {
                  next;
                }
                print $0;
              }
              END {
                if (printed==0) {
                  while ((getline line < "/tmp/details.md") > 0) print line;
                }
              }
            ' "$README" > /tmp/README.tmp && mv /tmp/README.tmp "$README"
          else
            # Insert block after first H1 heading if no existing heading found
            awk 'NR==1{print; print ""; while ((getline line < "/tmp/details.md") > 0) print line; next}1' "$README" > /tmp/README.tmp && mv /tmp/README.tmp "$README"
          fi

          # 5) show diff for logs
          git --no-pager diff -- "$README" || true

      - name: Commit & push if changed
        env:
          GIT_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_NAME: github-actions[bot]
        run: |
          set -euo pipefail

          # README variable is available from GITHUB_ENV
          echo "Using README path: '$README'"

          if [ -z "${README:-}" ] || [ ! -f "${README:-}" ]; then
            echo "README not set or missing; nothing to commit."
            exit 0
          fi

          git config user.email "$GIT_EMAIL"
          git config user.name "$GIT_NAME"

          if git status --porcelain | grep -q "$(basename "$README")"; then
            git add -- "$README"
            git commit -m "chore: update README Last Updated table" || echo "No commit created"
            git push origin HEAD:${{ github.ref_name }}
          else
            echo "No changes in README - nothing to commit."
          fi

# Note: If your repository or organization blocks GITHUB_TOKEN write access,
# use a Personal Access Token (PAT) pushed into repository secrets and the PAT-based push method (see earlier examples).
